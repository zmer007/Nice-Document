### 类加载过程
1. 加载：从 class 文件加载到方法区
2. 验证：class 文件是否符合 Java 字节码规范
3. 准备：为类变量分配内存并设置类变量初始值（空值）
4. 解析：将符号引用替换为直接引用
5. 初始化：此过程由开发者触发

### 类初始化时机
有且仅有以下五种

1. 执行 new, getstatic, putstatic, invokestaic 指令时，分别对应 new 关键字，获取静态变量，设置静态变量，调用静态方法
2. 调用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有被初始化，就会触发初始化
3. 当初始化一个类时，发现它的父类还没有初始化，就会先执行父类的初始化
4. JVM 虚拟机启动时会对主方法所在的类执行初始化
5. JDK 1.7 支持动态语言支持，遇到 REF_getstatic, REF_putstatic, REF_invokestatic 时会对类初始化

**反例**
1. 初始化数组不会引起相关类的初始化，如 `Object[] os = new Object[3]` 就不会初始化 Object 类
2. 使用子类调用父类的静态属性，只会导致父类初始化，子类不会初始化 
3. 静态常量不会引起初始化

### 初始化顺序
1. `<clinit>()` 方法（`<clinit>()` 方法是由编译器自动按代码顺序收集类中的所有 **类变量** 的赋值动作和静态语句块中的语句合并产生的）
2. 非静态字段
3. 构造器


### 其它问题
1 为什么单例饿汉模式能保证线程安全？
虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确加锁，同步。多个线程去初始化一个类时会被阻塞。所以如果在 `<clinit>()` 方中有耗时操作，会造成多个线程阻塞，如果这个线程完成了 `<clinit>()` 方法，其它线程不会再执行一次初始化类了，因为同一个类加载器下，一个类型只会初始化一次。



