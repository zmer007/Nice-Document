### volatile 作用
1. 保证变量的内存“可见性”
2. 禁止指令重排序

### synchronized 作用
1. synchronized 块之间的操作具备原子性
2. synchronized 块之间的变量具备内存可见性，因为“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中”（使用 final 和 volatile 也可以保证内存可见性）
3. synchronized 块之间的操作具备有序性，因为它具有原子性，所以它永远运行在单线程中，单线程中的操作都有顺序的（指令重排序对主义上的顺序没有影响）


### 其它
#### 指令重排序

为提高 CPU 运算效率，CPU 会对指令进行重新排序，比如 1 + 2 * 3 + 5 计算，CPU 有可能会按逻辑顺序计算，即 1 + 6 + 5 = 12，也可能会先算加法，比如 6 + 6 = 12，此过程中计算过程不一样但是结果是一样的。

指令重排序会保证方法的执行过程中所有依赖赋值的地方都能获取到正确的结果，而不能保证操作顺序与程序代码中的执行顺序一致

#### 变量在内存的交互操作

每个线程都有自己的工作内存，线程只变量的所有操作必须在工作内存中进行；线程不能直接访问其它线程的工作内存，线程间变量传递必须通过主内存完成。

主内存与工作内存之间的具体交互协议是通过以下 8 种操作完成的：

1. lock：对主内存变量加锁，把它标记为线程独占状态
2. unlock：将线程独占状态的变量解锁
3. read：作用于主内存的变量，把变量从主内存传输到工作内存
4. load: 作用于工作内存的变量，把从主内存拿到的变量放到工作内存的变量副本中
5. use: 将工作内存的变量传递给执行引擎，进行操作
6. assign: 执行引擎将操作后的结果赋值给变量
7. store：将工作内存变量传输给主内存
8. write: 将工作内存变量写入主内存

#### volatile 为什么能做到内存可见性
线程修改一个普通变量，此变量会经过 store 和 write 写回到主内存，然后才对其它线程可见。

线程修改一个 volatile 变量会立即同步到主线程，其它线程在操作该变量前也会从主线程刷新变量然后再进行操作。(先行发生原则规定 volite 变量读取值为最新值)


